name: Software Verification System

on:
  push:
    # tags:
      # - 'v*'
    branches: [ "main" ]
  # pull_request:
  #   branches: [ "main" ]

  workflow_dispatch:

env:
  MSBUILD_PATH: ''

jobs:
  Build-And-Analysis:
    runs-on: windows-latest
    
    permissions:
      security-events: write
      actions: write
      contents: write

    steps:
      - name: 코드 체크아웃
        uses: actions/checkout@v3
        with:
          lfs: true

      # - name: 태그 이름 추출
      #   id: get_tag_name
      #   shell: pwsh
      #   run: |
      #     # "${{ github.ref }}" 부분을 그대로 유지해야 합니다.
      #     # GitHub Actions 런타임이 이 부분을 실제 태그(예: "refs/tags/v1.0.0")로 치환합니다.
      #     $pureTagName = "${{ github.ref }}".Replace("refs/tags/", "")
          
      #     # 추출된 태그 이름을 이 스텝의 출력으로 설정합니다.
      #     echo "tag_name=$pureTagName" >> $env:GITHUB_OUTPUT
          
      #     # 디버깅을 위해 로그에 출력합니다.
      #     Write-Host "추출된 순수 태그 이름: $pureTagName"

      - name: Coverity 라이선스 파일 생성
        shell: pwsh
        env:
          COVERITY_LICENSE_CONTENT: ${{ secrets.COVERITY_ANALYSIS_LICENSE }} # Secrets에서 라이선스 내용을 가져옵니다.
        run: |
          $licenseFileName = "license.dat"
          $licenseFilePath = "./$licenseFileName" # 현재 작업 디렉토리(리포지토리 루트)에 저장

          if ([string]::IsNullOrWhiteSpace($env:COVERITY_LICENSE_CONTENT)) {
              Write-Error "ERROR: 'COVERITY_ANALYSIS_LICENSE' secret이 비어있거나 설정되지 않았습니다."
              Write-Host "GitHub 저장소의 Settings -> Secrets and variables -> Actions 에 'COVERITY_ANALYSIS_LICENSE' secret이 올바르게 설정되어 있는지 확인하세요."
              exit 1
          }

          # 라이선스 내용을 파일에 씁니다.
          # -NoNewline을 사용하여 Secret 값 끝에 불필요한 새 줄이 추가되지 않도록 합니다.
          $env:COVERITY_LICENSE_CONTENT | Out-File -FilePath $licenseFilePath -Encoding UTF8 -NoNewline
          
          if (-not (Test-Path $licenseFilePath)) {
              Write-Error "ERROR: 라이선스 파일($licenseFilePath) 생성에 실패했습니다."
              exit 1
          }
          Write-Host "라이선스 파일($licenseFilePath)이 성공적으로 생성되었습니다."
          # 보안을 위해 라이선스 파일의 내용은 로그에 출력하지 않습니다.
          # Get-Content $licenseFilePath | Write-Host # <-- 디버깅용: 라이선스 내용 확인 (실제 운영 시에는 주석 처리)


      - name: 분할 압축 파일 재조립 (원본 설치 파일 복원)
        shell: pwsh
        env:
          SPLIT_ARCHIVE_BASE_NAME: cov-analysis-win64-2024.12.1
          ARCHIVE_SUBDIR: .github/workflows # 파일이 있는 서브디렉토리 경로

        run: |
          Write-Host "7-Zip (7z.exe)을 사용하여 파일 재조립 시작..."
          
          $sevenZipPath = (Get-Command 7z.exe -ErrorAction SilentlyContinue).Path
          if (-not $sevenZipPath) {
              Write-Error "ERROR: 7-Zip (7z.exe)을 찾을 수 없습니다. 러너 환경에 문제가 있거나 경로에 없습니다."
              exit 1
          }
          Write-Host "7-Zip 실행 파일 경로: $sevenZipPath"
          
          $mainZipFile = "./${{ env.ARCHIVE_SUBDIR }}/${{ env.SPLIT_ARCHIVE_BASE_NAME }}.zip"
          $z01PartFile = "./${{ env.ARCHIVE_SUBDIR }}/${{ env.SPLIT_ARCHIVE_BASE_NAME }}.z01"

          if (-not (Test-Path $mainZipFile) -or -not (Test-Path $z01PartFile)) {
              Write-Error "ERROR: 재조립할 분할 압축 파일들을 찾을 수 없습니다."
              Write-Error "메인 ZIP 파일 경로: $mainZipFile"
              Write-Error "Z01 파일 경로: $z01PartFile"
              Write-Host "Git LFS 커밋 및 체크아웃 상태를 다시 확인하세요."
              exit 1
          }
          
          Write-Host "분할 파일($z01PartFile, $mainZipFile) 재조립 중..."
          & $sevenZipPath x "$mainZipFile" "-o./" -y

          if ($LASTEXITCODE -ne 0) {
              Write-Error "7-Zip 파일 재조립 실패. 종료 코드: $LASTEXITCODE"
              exit 1
          }
          
          $originalInstallerPath = Join-Path "./" "${{ env.COVERITY_ORIGINAL_INSTALLER_NAME }}"
          if (-not (Test-Path $originalInstallerPath)) {
              Write-Error "ERROR: 원본 설치 파일($originalInstallerPath)이 성공적으로 복원되지 않았습니다."
              Write-Host "압축 해제된 ZIP 파일 안에 '${{ env.COVERITY_ORIGINAL_INSTALLER_NAME }}' 파일이 있는지 확인하세요."
              exit 1
          }
          Write-Host "`n파일 재조립 완료! 원본 설치 파일이 복원되었습니다: $originalInstallerPath"
          Write-Host "복원된 파일 크기: $((Get-Item $originalInstallerPath).Length / 1MB) MB"

          # -----------------------------------------------------
          # 추가된 부분: 압축 해제된 파일 목록을 보여주기 위한 Get-ChildItem (dir) 명령어
          # -----------------------------------------------------
          Write-Host "`n==== 압축 해제 후 현재 디렉토리 파일 목록 ===="
          Get-ChildItem -Path "./" -File | Format-Table Name, Length, LastWriteTime -AutoSize
          Write-Host "============================================="
          # 특정 파일만 확인하려면:
          # Get-ChildItem -Path $originalInstallerPath | Format-Table Name, Length, LastWriteTime -AutoSize
          # -----------------------------------------------------


      # - name: Coverity 설치 프로그램 실행
      #   shell: pwsh
      #   env:
      #     COVERITY_ORIGINAL_INSTALLER_NAME: cov-analysis-win64-2024.12.1.exe
      #   run: |
      #     $installerPath = "./${{ env.COVERITY_ORIGINAL_INSTALLER_NAME }}" 
          
      #     if (-not (Test-Path $installerPath)) {
      #         Write-Error "ERROR: 실행할 설치 파일($installerPath)을 찾을 수 없습니다."
      #         exit 1
      #     }

      #     # -----------------------------------------------------------------
      #     # 추가된 부분: license.dat 파일의 절대 경로 (Full Path) 구성
      #     # -----------------------------------------------------------------
      #     $currentWorkingDirectory = Get-Location
      #     $licenseFullAbsolutePath = Join-Path $currentWorkingDirectory "license.dat"
          
      #     # 인자 문자열에 라이선스 파일의 절대 경로를 삽입합니다.
      #     # (인자에 공백이 포함될 경우를 대비하여 인용 부호 처리)
      #     $licensePathArgument = "--license.cov.path=`"$licenseFullAbsolutePath`""
          
      #     # 기존 인자들과 라이선스 경로 인자를 합칩니다.
      #     $installerArguments = "-q -console --installation.dir=C:\\Coverity --license.region=5 --license.agreement=agree --license.type.choice=0 $licensePathArgument"
      #     # -----------------------------------------------------------------
          
      #     Write-Host "Coverity 설치 프로그램 실행 중: $installerPath"
      #     Write-Host "사용할 인자: $installerArguments"
          
      #     Start-Process -FilePath "$installerPath" `
      #                   -ArgumentList "$installerArguments" `
      #                   -Wait `
      #                   -PassThru `
      #                   -RedirectStandardOutput "coverity_installer_stdout.log" `
      #                   -RedirectStandardError "coverity_installer_error.log" `
      #                   | Out-Null

      #     if ($LASTEXITCODE -ne 0) {
      #         Write-Error "Coverity 설치 프로그램 실행 중 오류 발생. 종료 코드: $LASTEXITCODE"
      #         exit 1
      #     }
      #     Write-Host "Coverity 설치 프로그램 실행 완료."
          
      #     $coverityBinPath = "C:\Coverity\bin"
      #     if (Test-Path $coverityBinPath) {
      #         $env:PATH += ";$coverityBinPath"
      #         Write-Host "Coverity CLI 경로가 PATH에 추가되었습니다."
      #         cov-build --version
      #     } else {
      #         Write-Warning "Coverity 설치 경로에 bin 폴더를 찾을 수 없어 PATH에 추가하지 못했습니다."
      #     }


      - name: 디스크 공간 확인 (GB 단위)
        shell: pwsh
        run: |
          Write-Host "==== 현재 러너의 디스크 공간 (GB 단위) ===="
          Get-PSDrive -PSProvider FileSystem | Select-Object Name, Root, @{Name='Free(GB)'; Expression={$_.Free / 1GB -as [int]}}, @{Name='Used(GB)'; Expression={$_.Used / 1GB -as [int]}}, @{Name='Size(GB)'; Expression={$_.Size / 1GB -as [int]}} | Format-Table -AutoSize
          Write-Host "============================================="

      - name: Coverity 설치 프로그램 실행 (라이선스 파일 절대 경로 사용)
        shell: pwsh
        env:
          COVERITY_ORIGINAL_INSTALLER_NAME: cov-analysis-win64-2024.12.1.exe
        run: |
          $installerPath = "${{ env.COVERITY_ORIGINAL_INSTALLER_NAME }}" 
          
          # Debugging variables
          Write-Host "DEBUG: 'COVERITY_ORIGINAL_INSTALLER_NAME' env 변수 값: ${{ env.COVERITY_ORIGINAL_INSTALLER_NAME }}"
          Write-Host "DEBUG: '$installerPath' 변수 값 (실행 전): $installerPath"

          if (-not (Test-Path $installerPath)) {
              Write-Error "ERROR: 실행할 설치 파일($installerPath)을 찾을 수 없습니다."
              exit 1
          }

          $currentWorkingDirectory = Get-Location
          $licenseFullAbsolutePath = Join-Path $currentWorkingDirectory "license.dat"
          $licensePathArgument = "--license.cov.path=`"$licenseFullAbsolutePath`""
          
          $installerArguments = "-q -console --installation.dir=C:\\Coverity --license.region=5 --license.agreement=agree --license.type.choice=0 $licensePathArgument"
          
          Write-Host "Coverity 설치 프로그램 실행 중: $installerPath"
          Write-Host "사용할 인자: $installerArguments"
          
          # -----------------------------------------------------------------
          # 변경된 부분: Start-Process 대신 직접 '&' 호출 연산자 사용
          # 이렇게 하면 설치 프로그램의 콘솔 출력이 GitHub Actions 로그에 직접 표시됩니다.
          # -----------------------------------------------------------------
          try {
              # 실행 파일과 인자들을 직접 호출합니다.
              # 인자들이 많거나 공백이 포함될 경우 배열로 전달하는 것이 더 안전하지만,
              # 여기서는 인자들이 하나의 문자열로 이미 구성되어 있으므로 PowerShell이 파싱하도록 둡니다.
              # 만약 이 방법으로도 인자 파싱 문제가 생긴다면 배열로 명시해야 합니다.
              
              & "$installerPath" $installerArguments
              
              $exitCode = $LASTEXITCODE # 실행된 프로세스의 종료 코드를 가져옵니다.
          } catch {
              # 호출 자체에 문제가 있을 경우 (예: 파일 경로 오류, 권한 오류)
              Write-Error "Coverity 설치 프로그램 호출 중 PowerShell 예외 발생: $($_.Exception.Message)"
              $exitCode = 9999 # 예외 발생 시 임의의 종료 코드 설정 (0이 아닌 값)
          }
          
          if ($exitCode -ne 0) {
              Write-Error "Coverity 설치 프로그램 실행 중 오류 발생. 종료 코드: $exitCode"
              
              # --- 설치 프로그램 자체 로그 파일 확인 로직 유지 ---
              # 콘솔 출력이 적더라도, 이 로그 파일들이 가장 상세한 정보를 담고 있을 가능성이 높습니다.
              $coveritySpecificLog1 = "C:\Coverity\install_log.txt" # 일반적인 로그 파일명
              $coveritySpecificLog2 = Join-Path $env:TEMP "coverity_installer_*.log" # %TEMP%에 생성될 수 있는 패턴
              
              Write-Host "`n==== Coverity 설치 프로그램 자체 로그 파일 확인 (필수) ===="
              if (Test-Path $coveritySpecificLog1) {
                  Write-Host "상세 로그 ($coveritySpecificLog1) 내용:"
                  Get-Content $coveritySpecificLog1 | Write-Host
              } else {
                  Write-Host "상세 로그 ($coveritySpecificLog1)를 찾을 수 없습니다."
              }
              Get-ChildItem -Path $env:TEMP -Filter "coverity_installer_*.log" | ForEach-Object {
                  Write-Host "임시 폴더 로그 ($($_.FullName)) 내용:"
                  Get-Content $_.FullName | Write-Host
              } | Out-Null # 출력 억제
              Write-Host "======================================================"
              
              exit 1 # 워크플로우를 실패 처리
          }
          Write-Host "Coverity 설치 프로그램 실행 완료."
          
          # ... (이후 Coverity CLI 경로 설정 및 확인 스텝 동일) ...

